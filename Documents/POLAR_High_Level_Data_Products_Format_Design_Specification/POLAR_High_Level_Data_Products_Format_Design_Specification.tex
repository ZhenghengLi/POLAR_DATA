\documentclass[a4paper, 12pt, onecolumn]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage[colorlinks]{hyperref}
\usepackage{supertabular}
\usepackage{fancyvrb}
\usepackage[aboveskip=5pt, belowskip=0pt]{caption}
\usepackage{array}
\usepackage{paralist}
\renewcommand{\thempfootnote}{\arabic{mpfootnote}}

\newcommand{\versDoc}{0.1}
\newcommand{\codeDoc}{POLAR\_TN\_410}
\newcommand{\kindDoc}{Technical Note}

\begin{document}
% ==== title page =====================
\begin{titlepage}
  \centering
  \vspace*{4cm}
  \begin{flushleft}
    \huge \bf POLAR \\ High Level Data Products \\ Format Design Specification
  \end{flushleft}
  \vspace*{6cm}
  
  \begin{tabular}{ l l }
    Document No   & : \codeDoc \\
    Issue         & : \versDoc \\
    Date          & : \today   \\
  \end{tabular}
  \vfill
  \begin{tabular}{ | l | l | l | l | }
    \hline
                & \bf Name     & \bf Signature  & \bf Date      \\\hline
    Prepared by & Zhengheng Li &                & May 20, 2016  \\\hline
    Reviewed by &              &                &               \\\hline
    Aproved by  &              &                &               \\\hline
  \end{tabular}
\end{titlepage}

% ==== header and footer
\pagestyle{fancy}
\lhead{\small \bf POLAR -- \kindDoc}
\chead{}
\rhead{\small \bf \codeDoc}
\lfoot{\today}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.1pt}

% ==== table of conents ===============
\pagenumbering{Roman}
\tableofcontents
\newpage
\pagenumbering{arabic}

% ==== begin main contents ================
\section{Introduction}
This chapter contains an introduction to the document ``POLAR High Level Data Products Format Design Specification''

\subsection{Purpose of the document}
Three core pre-processing programs of POLAR SCI and HK raw data have been finished. 
They are \texttt{SCI\_Decode}, \texttt{HK\_Decode} and \texttt{Time\_Calculate}.
For raw data products from POAC, please see the document\cite{POAC-data-products}.
\texttt{SCI\_Decode} is to directly decode 0B level POLAR SCI raw data from POAC, and do time sync at the same time. 
\texttt{HK\_Decode} is to directly decode 0B level POLAR HK raw data from POAC, and do some physical value converting work.
\texttt{Time\_Calculate} is to calculate the absolute GPS time of each event in SCI decoded data using the GPS and timestamp sync information in HK decoded data.
These three programs are tested by lots of ground data and work well. One important thing is the format or data structure of the output data files.
Everyone who uses these programs should know the format and the way of data organization.
This document is mainly to clarify the data structure of decoded data produced by the three pre-processing programs.

\subsection{Levels of data products}
POLAR data products has several different levels. 1M level data is the directly decoded data produced by \texttt{SCI\_Decode} or \texttt{HK\_Decode}.
It should keep all information in 0B level raw data, and add some auxiliary data which is helpful for data monitor and data analysis later. 
The level of SCI data after absolute GPS time of each event is calculated and added by \texttt{Time\_Calculate} is 1P.
1M and 1P level SCI data have almost the same data structure except for absolute GPS time added.
HK data does not have 1P level, because 1M level HK data already have absolute GPS time.

One raw data file from POAC could be very big, because it may contain a day of data.
The time span of one orbit is about 90 minutes, so it could be convenient to split the data by orbit.
The data structure of orbit splitted data should be the same as the data that is not splitted.
So, data monitor and data analysis software can directly process the data after and before splitted without any change.
The level of orbit splitted data is 1R.

This document will give a clear clarification of data structure of 1M and 1P level SCI decoded data, 1M level HK decoded data.
SCI data of one event include one trigger packet and one or more module packets.
It is important to understand the data organization of event data in the output ROOT file.

\section{Usage of the three programs}
Before introducing the data products format, this chapter gives a brief introduction to how to use the three core pre-processing programs.

\subsection{Usage of \texttt{SCI\_Decode} and \texttt{HK\_Decode}}
The way of using the two decoding programs \texttt{SCI\_Decode} and \texttt{HK\_Decode} are the same, we can run one of them without any command line parameters to see the help information.

Help information of \texttt{SCI\_Decode} is as following:
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
> SCI_Decode
Usage:
  SCI_Decode [-l <listfile.txt>] [<POL_SCI_data_001.dat> <POL_SCI_data_002.dat> ...]
             [-o <POL_SCI_decoded_data.root>] [-g <POL_SCI_decoding_error.log>]

Options:
  -l <listfile.txt>                text file that contains raw data file list
  -o <decoded_data.root>           root file that stores decoded data
  -g <decoding_error.log>          text file that records decoding error log info

  --version                        print version and author information
\end{Verbatim}

And help information of \texttt{HK\_Decode} is as following:
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
> HK_Decode
Usage:
  HK_Decode [-l <listfile.txt>] [<POL_HK_data_001.dat> <POL_HK_data_002.dat> ...]
            [-o <POL_HK_decoded_data.root>] [-g <POL_HK_decoding_error.log>]

Options:
  -l <listfile.txt>                text file that contains raw data file list
  -o <decoded_data.root>           root file that stores decoded data
  -g <decoding_error.log>          text file that records decoding error log info

  --version                        print version and author information
\end{Verbatim}

There are two ways to input raw data files.

The first way is directly to use command line parameters without options to give file names as following:

\begin{Verbatim}[fontsize=\scriptsize, frame=single]
> SCI_Decode POL_SCI_data_20160517_154345_001.dat POL_SCI_data_20160517_154345_002.dat ...
\end{Verbatim}

\texttt{SCI\_Decode} will scan the designated raw data files one by one from left to right and generate only one decoded ROOT file.
The default name of the output file is \texttt{POL\_SCI\_decoded\_data.root} for \texttt{SCI\_Decode} if it is not specified by option \texttt{-o}.

The second way is to use a text file which contains all the file names line by line. And use option \texttt{-l} to input the raw data files. Just as following:

\begin{Verbatim}[fontsize=\scriptsize, frame=single]
> cat listfile.txt
path/to/POL_SCI_data_20160517_154345_001.dat
path/to/POL_SCI_data_20160517_154345_002.dat
path/to/POL_SCI_data_20160517_154345_003.dat
...
> SCI_Decode -l listfile.txt
\end{Verbatim}

Options \texttt{-o} and \texttt{-g} are optional. We can use option \texttt{-o} to specify the name of output decoded file.
If option \texttt{-g} is used, \texttt{SCI\_Decode} and \texttt{HK\_Decode} will record some log information into a text file,
including the raw data of bad packets.

After a run of \texttt{SCI\_Decode} or \texttt{HK\_Decode} finished, some counter information will be printed out,
including count of total frames and packets, count of CRC error, count and percentage of packets lost, percentage of time aligned event packets, etc..
Such counter information can give some indications of quality of the raw data.

Screen output of \texttt{SCI\_Decode} is as following:
\begin{Verbatim}[fontsize=\tiny, frame=single]
POL_SCI_data_20160517_154345_001.dat
POL_SCI_data_20160517_154345_002.dat
POL_SCI_data_20160517_154345_003.dat
===========================================================================================================
total frame count:          783485              total packet count:         17786003  
frame invalid count:        0                   - trigger packet count:     8090369   
frame invalid percent:      0.00%               - event packet count:       9695515   
frame crc error count:      0                   packet invalid count:       65        
frame crc error percent:    0.00%               packet invalid percent:     0.00%     
frame interruption count:   0                   packet crc error count:     633       
frame start error count:    0                   packet crc error percent:   0.00%     
total timestamp 0 count:    0                   packet too short count:     291                 
-----------------------------------------------------------------------------------------------------------
  ct  mod  >   ped_trig  ped_event   ped_lost  percent    |   noped_trig  noped_event   noped_lost  percent
   1  405  >        766        766          0    0.00%    |       261973       261973            0    0.00%
   2  639  >        766        766          0    0.00%    |       340300       340300            0    0.00%
   3  415  >        765        765          0    0.00%    |       359015       359014            1    0.00%
   4  522  >        758        758          0    0.00%    |       361436       361436            0    0.00%
   5  424  >        763        763          0    0.00%    |       322721       322721            0    0.00%
   6  640  >        763        763          0    0.00%    |       317664       317663            1    0.00%
   7  408  >        760        760          0    0.00%    |       406439       406439            0    0.00%
   8  638  >        757        757          0    0.00%    |       448543       448543            0    0.00%
   9  441  >        758        758          0    0.00%    |       471523       471523            0    0.00%
  10  631  >        758        758          0    0.00%    |       418859       418859            0    0.00%
  11  411  >        769        769          0    0.00%    |       305021       305021            0    0.00%
  12  505  >        757        756          1    0.13%    |       426402       426403           -1   -0.00%
  13  503  >        759        759          0    0.00%    |       495925       495925            0    0.00%
  14  509  >        742        742          0    0.00%    |       519941       519941            0    0.00%
  15  410  >        762        762          0    0.00%    |       420677       420677            0    0.00%
  16  507  >        769        769          0    0.00%    |       321857       321857            0    0.00%
  17  402  >        758        758          0    0.00%    |       392200       392200            0    0.00%
  18  602  >        754        754          0    0.00%    |       506862       506861            1    0.00%
  19  414  >        765        765          0    0.00%    |       482388       482388            0    0.00%
  20  524  >        747        746          1    0.13%    |       437999       437999            0    0.00%
  21  423  >        766        766          0    0.00%    |       246196       246194            2    0.00%
  22  601  >        761        761          0    0.00%    |       365308       365308            0    0.00%
  23  406  >        770        767          3    0.39%    |       326266       325397          869    0.27%
  24  520  >        771        771          0    0.00%    |       402897       402897            0    0.00%
  25  413  >        768        768          0    0.00%    |       317960       317960            0    0.00%
-----------------------------------------------------------------------------------------------------------
trigg expected sum: 9695404        noped_trigger:   8089584             ped_trigger:     785                 
event received sum: 9694526        noped_event_sum: 9675499             sec_ped_trigger: 636                 
total lost percent: 0.01%          mean event rate: 12719 cnts/sec      np_evts per sec: 15213 pkts/sec      
transmission rate:  19.96 Mbps     aligned sum:     9675497             aligned percent: 100.00%             
===========================================================================================================
\end{Verbatim}

\newpage

Screen output of \texttt{HK\_Decode} is as following:

\begin{Verbatim}[fontsize=\tiny, frame=single]
POL_HK_data_20160517_154345_001.dat
=============================================================================================
total frame count:          12564               total obox packet count:    6282                
frame valid count:          12564               obox valid count:           6281                
frame invalid count:        0                   obox invalid count:         1                   
frame crc passed:           12564               obox crc passed:            6281                
frame crc error count:      0                   obox crc error count:       0                   
frame interruption count:   0                   
=============================================================================================
\end{Verbatim}

\subsection{Usage of \texttt{Time\_Calculate}}
\texttt{Time\_Calculate} is used to calculate and add the absolute GPS time of each event in decoded SCI data.
It can work only when the GPS time in HK data is valid. We can also run this program without any command line parameters to see the help information.

Help information of \texttt{Time\_Calculate} is as following:
\begin{Verbatim}[fontsize=\tiny, frame=single]
Usage:
  Time_Calculate <POL_SCI_decoded_data.root> -k <POL_HK_decoded_data.root>
                 [-o <POL_SCI_decoded_data_time.root>] [-g <POL_SCI_time_error.log>]

Options:
  -k <hk_decoded_data.root>        root file that stores hk decoded data
  -o <sci_decoded_data.root>       root file that stores sci decoded data after absolute time is added
  -g <time_error.log>              text file that records time calculating error log info

  --version                        print version and author information
\end{Verbatim}

It is very straightforward. Just use option \texttt{-k} to designate the file name of decoded HK data.
Options \texttt{-o} and \texttt{-g} are also optional. Option \texttt{-o} is used to specify the file name of the output ROOT file that stores the SCI data after
absolute GPS time is added. If option \texttt{-o} is not used, the default file name is \texttt{POL\_SCI\_decoded\_data\_time.root}.
When option \texttt{-g} is used, this program will record some error log information into a text file.

Screen output of \texttt{Time\_Calculate} is as following:

\begin{Verbatim}[fontsize=\scriptsize, frame=single]
Copying physical modules data ...
[ ################################################# DONE ] 
Calculating time and copying physical trigger data ...
[ ################################################# DONE ] 
Copying pedestal modules data ...
[ ################################################# DONE ] 
Calculating time and copying pedestal trigger data ...
[ ################################################# DONE ] 
================================================================================
phy_error_count: 0 / 8089584         ped_error_count: 0 / 785             
================================================================================
\end{Verbatim}

Absolute GPS time is only added into trigger packets, and all of other data is just copied.

\section{Data Structure of ROOT files}
This chapter gives a detail explanation of the TTree structure of 1M/1P level SCI data and 1M level HK data.
The way of data organization of SCI event data is also clarified in this chapter.
It is helpful to know the structure of raw data of SCI and HK first.
See chapter 3 (page 13--17) of document\cite{POLAR-data-link} to know the frame structure of SCI and HK raw data, and packet structure of HK data.
See section 3.4.2 (page 59--64) of document\cite{POLAR-OBOX-software}  to know the structure of raw HK packet from OBOX.
See section 3.4.3 and 3.4.4 (page 65--68, 78--83) of document\cite{POLAR-OBOX-software} to know the structure of raw science data packet and trigger data packet.
In the ROOT files of decoded data, some data are directly decoded data, and others are auxiliary data that are added or calculated when decoding.

\subsection{1M/1P level SCI data}
SCI data of 1M level is generated by \texttt{SCI\_Decode}.
There are 4 TTree objects, which store decoded data, and some TNamed objects, which store meta information.
Descriptions of them are shown in Table \ref{tab:1m-sci}

\begin{table}[htbp]
%  \setlength{\abovecaptionskip}{2pt}
%  \setlength{\belowcaptionskip}{6pt}
  \centering
  \caption{Contents of ROOT file of 1M/1P SCI data}\label{tab:1m-sci}
  \begin{tabular}{| l | l | l |}\hline
    \textbf{Type}    & \textbf{Name}    & \textbf{Descriptions}      \\\hline
    TTree            & t\_modules       & physical modules packets   \\\hline
    TTree            & t\_trigger       & physical trigger packets   \\\hline
    TTree            & t\_ped\_modules  & pedestal modules packets   \\\hline
    TTree            & t\_ped\_trigger  & pedestal trigger packets   \\\hline
    TNamed           & m\_dattype       & string of description of the data type   \\\hline
    TNamed           & m\_version       & version of the program that generate this file  \\\hline
    TNamed           & m\_gentime       & string of time when this file is generated \\\hline
    TNamed           & m\_rawfile       & list of file names of the raw data  \\\hline
    TNamed           & m\_dcdinfo       & some information calculated when decoding \\\hline
  \end{tabular}
\end{table}

The two TTree objects t\_modules and t\_trigger are used to store physical event data.
t\_modules is for module packets from 25 FEEs, and t\_trigger is for trigger packets from CT.
These two TTree objects are associated by a specific way to match trigger packet and its corresponding module packets of the same physical event.
The way of data organization of physical event data will be introduced later.
The other two TTree objects t\_ped\_modules and t\_ped\_trigger are used to store pedestal event data.
Actually, they have exactly the same structure of t\_modules and t\_trigger.
The reason of storing physical events and pedestal events separately is that it is hard to make the order between physical packets and pedestal packets sequencially as time 
because of the different methods of doing time sync for physical events and pedestal events.
After these two kinds of events are stored separately, it is easy to make the order of both trigger and module packets right as time.
And it is not hard to iterate all packets (including pedestal and physical, excluding bad) of one module as the order of time by using a global index number.
The method will be introduced later.

\subsubsection{Contents table of TTree}
Here will introduce the data structure of TTree t\_modules and TTree t\_trigger.

Firstly, contents of TTree t\_modules and t\_ped\_modules are shown in Table \ref{tab:t-modules}.

\begin{center}
  \tablecaption{Contents of TTree t\_modules and t\_ped\_modules}\label{tab:t-modules}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{3}{r}{\small Table \ref{tab:t-modules} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{3}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{mpsupertabular}{| p{28mm} | p{25mm} | p{70mm} |}
    Long64\_t          & trigg\_num          & Sequential number of the trigger packet of an event. \\\hline
    Long64\_t          & event\_num          & Sequential number of the event packet\footnote{When I say event packet, it is equal to module packet} of a module. \\\hline
    Long64\_t          & event\_num\_g       & Order number of the sequence of appearing in the raw data file. \\\hline
    Int\_t             & is\_bad             & if the packet is invalid or has CRC error. \\\hline
    Int\_t             & pre\_is\_bad        & if the previous packet is invalid or has CRC error. \\\hline
    Int\_t             & compress            & compress mode \\\hline
    Int\_t             & ct\_num             & CT number \\\hline
    UInt\_t            & time\_stamp         & raw data of TIMESTAMP field of the packet \\\hline
    UInt\_t            & time\_period        & overflow counter of time\_stamp \\\hline
    UInt\_t            & time\_align         & 23 LSB of time\_stamp  \\\hline
    Double\_t          & time\_second        & time in seconds from start  \\\hline
    Double\_t          & time\_wait          & time\_second difference since previous event \\\hline
    Int\_t             & raw\_rate           & raw data of RATE field of the packet \\\hline
    UInt\_t            & raw\_dead           & raw data of DEADTIME field of the packet \\\hline
    Float\_t           & dead\_ratio         & delta(raw\_dead) / delta(time\_stamp) \\\hline
    UShort\_t          & status              & raw data of the 16 bits STATUS field of the packet \\\hline
    Event\_Status\_T   & status\_bit         & each bit in status \\\hline
    Bool\_t            & trigger\_bit[64]    & raw data of the TRIGGERBIT \\\hline
    Float\_t           & energy\_adc[64]     & ADC of energy of the 64 channels \\\hline
    Float\_t           & common\_noise       & COMMON NOISE for compress mode 3 \\\hline
    Int\_t             & multiplicity        & sum of trigger\_bit[64] of this packet \\
  \end{mpsupertabular}
\end{center}

Type Event\_Status\_T is a C struct. It is used to extract and store each bit of status. Definition of it is shown in Table \ref{tab:event-status-bit}.

\begin{center}
  \tablecaption{Definition of struct Event\_Status\_T}\label{tab:event-status-bit}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Bit}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{4}{r}{\small Table \ref{tab:event-status-bit} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Bit}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{4}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{supertabular}{| p{15mm} | p{34mm} | p{7mm} | p{63mm} |}
    Bool\_t   & trigger\_fe\_busy       & 15  & Flag indicating Frontend Unit is busys. \\\hline
    Bool\_t   & fifo\_full              & 14  & Flag indicating FIFO memory for events is full. \\\hline
    Bool\_t   & fifo\_empty             & 13  & Flag indicating FIFO memory for events is empty. \\\hline
    Bool\_t   & trigger\_enable         & 12  & Flag indicating trigger is enabled. \\\hline
    Bool\_t   & trigger\_waiting        & 11  & Flag indicating FE is waiting for trigger acceptance. \\\hline
    Bool\_t   & trigger\_hold\_b        & 10  & Flag indicating HOLD B signal on FE is asserted. \\\hline
    Bool\_t   & timestamp\_enable 	    & 9   & Flag indicating timestamp is enabled. \\\hline
    Bool\_t   & reduction\_mode\_b1     & 8   & bit 1 of Field indicating the reduction mode of the Frontend Unit. \\\hline
    Bool\_t   & reduction\_mode\_b0     & 7   & bit 0 of Field indicating the reduction mode of the Frontend Unit. \\\hline
    Bool\_t   & subsystem\_busy         & 6   & Flag indicating one of three subsystems is busy. \\\hline
    Bool\_t   & dynode\_2               & 5   & Flag indicating DYNODE 2 triggered. \\\hline
    Bool\_t   & dynode\_1               & 4   & Flag indicating DYNODE 1 triggered. \\\hline
    Bool\_t   & dy12\_too\_high         & 3   & Flag indicating DY12 TOO HIGH triggered. \\\hline
    Bool\_t   & t\_out\_too\_many       & 2   & Flag indicating T OUT TOO MANY triggered. \\\hline
    Bool\_t   & t\_out\_2               & 1   & Flag indicating T OUT 2 triggered. \\\hline
    Bool\_t   & t\_out\_1               & 0   & Flag indicating T OUT 1 triggered. \\
  \end{supertabular}
\end{center}

Then, contents of TTree t\_trigger and t\_ped\_trigger are shown in Table \ref{tab:t-trigger}.

\begin{center}
  \tablecaption{Contents of TTree t\_trigger and t\_ped\_trigger}\label{tab:t-trigger}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{3}{r}{\small Table \ref{tab:t-trigger} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{3}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{supertabular}{| p{28mm} | p{29mm} | p{66mm} |}
    Long64\_t          & trigg\_num           & Sequential number of the trigger packet of an event. \\\hline
    Long64\_t          & trigg\_num\_g        & Order number of the sequence of appearing in the raw data file. \\\hline
    Int\_t             & is\_bad              & if the packet is invalid or has CRC error. \\\hline
    Int\_t             & pre\_is\_bad         & if the previous packet is invalid or has CRC error. \\\hline
    Int\_t             & type                 & code of the 4 types of trigger packet \\\hline
    Int\_t             & packet\_num          & raw data of packet number of the trigger packet \\\hline
    UInt\_t            & time\_stamp          & raw data of Timestamp register of the trigger packet \\\hline
    UInt\_t            & time\_period         & overflow counter of time\_stamp \\\hline
    UInt\_t            & time\_align          & 23 MSB of time\_stamp \\\hline
    Double\_t          & time\_second         & time in seconds from start \\\hline
    Double\_t          & time\_wait           & time\_second difference since previous event \\\hline
    ULong64\_t         & frm\_ship\_time      & raw data of the ship time from frame in which this packet is. \\\hline
    ULong64\_t         & frm\_gps\_time       & raw data of the GPS time from frame in which this packet is. \\\hline
    Long64\_t          & pkt\_start           & first entry index of all the adjacent event packets of this event in the modules tree. \\\hline
    Int\_t             & pkt\_count           & number of entries of event packets for this event in the modules tree \\\hline
    Int\_t             & lost\_count          & number of lost event packets for this event \\\hline
    Int\_t             & trigger\_n           & sum of the trigger\_bit[64] of all the event packets for this event \\\hline
    UShort\_t          & status               & raw data of Status register of the trigger packet \\\hline
    Trigg\_Status\_T   & status\_bit          & each bit in status \\\hline
    UChar\_t           & trig\_sig\_con[25]   & raw data of Trigger signals conditions for each frontend \\\hline
    Trig\_Sig\_Con\_T  & trig\_sig\_con\_bit  & each bit in trig\_sig\_con[25] for each frontend \\\hline
    Bool\_t            & trig\_accepted[25]   & raw data of FEE TRIGGER ACCEPTED for each frontend \\\hline
    Bool\_t            & trig\_rejected[25]   & raw data of FEE TRIGGER REJECTED for each frontend \\\hline
    UInt\_t            & raw\_dead            & raw data of the dead time counter field \\\hline
    Float\_t           & dead\_ratio          & delta(raw\_dead) / delta(time\_stamp) / 4 \\\hline
    Int\_t             & abs\_gps\_week$^*$   & week of absolute gps time of this event. \\\hline
    Double\_t          & abs\_gps\_second$^*$ & second of absolute gps time of this event. \\\hline
    Bool\_t            & abs\_gps\_valid$^*$  & if the absolute gps time is valid. \\
  \end{supertabular}
\end{center}

Type Trigg\_Status\_T and Trig\_Sig\_Con\_T are C structs. They are used to extract and store each bit of status and trig\_sig\_con[25] respectively.
Definitions of the two struct types are shown in Table \ref{tab:trigg-status-bit} and Table \ref{tab:trig-sig-con-bit} respectively.

\newpage

\begin{center}
  \tablecaption{Definition of struct Trigg\_Status\_T}\label{tab:trigg-status-bit}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Bit}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{4}{r}{\small Table \ref{tab:trigg-status-bit} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Bit}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{4}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{supertabular}{| p{15mm} | p{37mm} | p{7mm} | p{60mm} |}
    Bool\_t   & science\_disable        & 15  & Flag indicating the science packets generation by Central Trigger Unit is disabled. \\\hline
    Bool\_t   & master\_clock\_enable   & 14  & Flag indicating the Master Clock generation is enabled. \\\hline
    Bool\_t   & saving\_data            & 13  & Flag indicating the science packet is being stored in FIFO. \\\hline
    Bool\_t   & taking\_event\_or\_ped  & 12  & Flag indicating the Central Trigger Unit state machine is doing the event or pedestal acquisition. \\\hline
    Bool\_t   & fifo\_full              & 11  & Flag indicating FIFO in Central Processing Unit is full. \\\hline
    Bool\_t   & fifo\_almost\_full      & 10  & Flag indicating FIFO in Central Processing Unit is almost full. \\\hline
    Bool\_t   & fifo\_empty             & 9   & Flag indicating FIFO in Central Processing Unit is empty. \\\hline
    Bool\_t   & fifo\_almost\_empty     & 8   & Flag indicating FIFO in Central Processing Unit is almost empty. \\\hline
    Bool\_t   & any\_waiting            & 7   & Flag indicating at least one FEE sent the WAITING signal to Central Processing Unit. \\\hline
    Bool\_t   & any\_waiting\_two\_hits & 6   & Flag indicating at least one FEE, that has two hits, sent the WAITING signal to Central Processing Unit. \\\hline
    Bool\_t   & any\_tmany\_thigh       & 5   & Flag indicating at least one FEE, that has Too Many or Too High flags set, sent the WAITING signal to Central Processing Unit. \\\hline
    Bool\_t   & packet\_type\_b2        & 4   & bit 2 of Field indicating the type of science packet being processed by the state machine of Central Trigger Unit. \\\hline
    Bool\_t   & packet\_type\_b1        & 3   & bit 1 of Field indicating the type of science packet being processed by the state machine of Central Trigger Unit. \\\hline
    Bool\_t   & packet\_type\_b0        & 2   & bit 0 of Field indicating the type of science packet being processed by the state machine of Central Trigger Unit. \\
  \end{supertabular}
\end{center}

\begin{center}
  \tablecaption{Definition of struct Trig\_Sig\_Con\_T}\label{tab:trig-sig-con-bit}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Bit}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{4}{r}{\small Table \ref{tab:trig-sig-con-bit} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Bit}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{4}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{supertabular}{| p{15mm} | p{34mm} | p{7mm} | p{63mm} |}
    Bool\_t   & fe\_busy[25]         & 5  & Flag indicating the status of the FE BUSY signal from this Frontend Unit. \\\hline
    Bool\_t   & fe\_waiting[25]      & 4  & Flag indicating the status of the FE WAITING signal from this Frontend Unit. \\\hline
    Bool\_t   & fe\_hold\_b[25]      & 3  & Flag indicating the status of the FE HOLD B signal from this Frontend Unit. \\\hline
    Bool\_t   & fe\_tmany\_thigh[25] & 2  & Flag indicating the status of the FE TMANY THIGH signal from this Frontend Unit. \\\hline
    Bool\_t   & fe\_tout\_2[25]      & 1  & Flag indicating the status of the FE TOUT 2 signal from this Frontend Unit. \\\hline
    Bool\_t   & fe\_tout\_1[25]      & 0  & Flag indicating the status of the FE TOUT 1 signal from this Frontend Unit. \\
  \end{supertabular}
\end{center}

\subsubsection{Directly decoded data in t\_modules}
Some data in t\_modules is directly decoded from module packet without any change. Here list and explain all of them.

\begin{asparadesc}
\item[compress] Bit [8:7] of module status word. It is the code of reduction mode. There are four different reduction mode types.
  0 is for default mode, 1 is for simple mode, 2 is for pedestal mode, and 3 is for full reduction mode.
\item[ct\_num] This is the CT number, raw data of FEE Unit number. The range of it is from 1 to 25, indicating which module this packet is from.
\item[time\_stamp] Raw data of TIMESTAMP field of this packet. The number of valid bits is 24. The unit of it is $40.96\mu s$.
\item[raw\_rate] Raw data of RATE word of this packet.
\item[raw\_dead] Raw data of DEADTIME word of this packet. The unit of it is the same as TIMESTAMP.
\item[status] Raw data of module STATUS word.
\item[status\_bit] This is a C struct of pure bool type. Each bit of STATUS word is extracted and stored in this struct respectively.
  Names of the fields indicate the meaning of each bit.
\item[trigger\_bit[64]] Array of each bit of TRIGGERBIT. The type of it is Bool\_t. True means the corresponding channel is triggered.
\item[energy\_adc[64]] Array of ADC of each channel. For mode 2 and mode 3, some channels have no ADC data, in this case, ADC of the channel is 0.
  ADC of mode 3 is special. The output ADC of mode 3 is $(ADC_{raw} - 2048) \times 2$. After this calculation, the unit of ADC of mode 3 is the same as other modes.
  One important thing is that ADC of mode 3 is already pedestal subtracted in firmware, but common noise is not subtracted.
  The common noise for mode 3 is stored in common\_noise.
  For mode 0, 1 and 2, the output ADC is equal to the raw ADC.
\item[common\_noise] Raw data of COMMON NOISE for mode 3 is subtracted by 2048. The reason to subtract 2048 is that firmware add an extra 2048 to common noise.
  For ohter compress modes, the value of common\_noise is 0.
\end{asparadesc}

\subsubsection{Auxiliary data in t\_modules}
One important fact is that packets of a specific module and trigger packets are ordered exactly as time in the raw data file.
It is better to add some auxiliary data related to the sequence of time that is helpful for data monitor and data analysis later.
All of the auxiliary data in t\_modules is listed and explained here.

\begin{asparadesc}
\item[trigg\_num] This is the sequential number of trigger packet of this event. Module packets which belong to the same event have the same trigg\_num.
  This number is used for organization of event data. It start from 0. It is -1 if this module packet has no corresponding trigger packet and -2 when this module packet is bad.
\item[event\_num] Sequential number of module packets. This number for different modules is independent. This number is added when saving data into TTree.
  In ohter words, this number is also independent for pedestal and physical packets.
  This number is continuous and incremental for a specific module in the same TTree, t\_modules or t\_ped\_modules.
  It start from 0, and it is $-1$ when this packet is bad.
\item[event\_num\_g] Order number of the sequence of appearing in the raw data file. This number for different modules is independent.
  The difference between this number and event\_num is that this number is added when scanning the raw data file. It counts both pedestal and physical packets.
  Because pedestal and physical packets are stored in different TTree, this number is incremental but sometimes discontinuous for a specific module in the same TTree.
  It start from 0, and it is $-1$ when this packet is bad. This number is used for iterating all packets of one module including pedestal and physical as the order of time.
\item[is\_bad] An integer value that indicates whether this packet is bad. The value is 3 when this packet is too short, 2 when invalid, 1 when CRC error, and 0 when good.
  The value is $-1$ when this packet is good but the timestamp is 0.
\item[pre\_is\_bad] Value of is\_bad of the previous packet of the same module.
  This value is necessary because if the previous packet is bad, some ohter auxiliary data in t\_modules such as time\_wait, dead\_ratio is unknown and wrong.
\item[time\_period] time\_stamp of module packet will overflow about every 11.45 minutes. This value records the total number of overflow from start.
\item[time\_align] It is the 23 LSB of time\_stamp of this packet. This is useful for time alignment. It is the counterpart of 23 MSB of time\_stamp of trigger packet,
  that is the time\_align of trigger packet. time\_align of both module packet and trigger packet have the same time unit and range.
\item[time\_second] This is the time in second unit from start. It is equal to $(\textrm{time\_period}\times 2^{24} + \textrm{time\_stamp})\times 40.96 \times 10^{-6}$
\item[time\_wait] This is the difference of time\_second between this packet and previous packet of the same module. The unit of it is second.
\item[dead\_ratio] Ratio of the increment of raw\_dead to the increment of \\ time\_stamp. The increment is between this packet and previous packet of the same module.
  In formula, $\textrm{dead\_ratio} = \Delta(\textrm{raw\_dead}) / \Delta(\textrm{time\_stamp})$.
\item[multiplicity] Sum of array trigger\_bit[64] of this packet. It indicates how many bars of this module is fired.
\end{asparadesc}

\subsubsection{Directly decoded data in t\_trigger}
Here list and explain the directly decoded data of trigger packet in TTree t\_trigger.

\begin{asparadesc}
\item[type] Code of the 4 types of trigger packet.
  0x00F0 is for pedestal event, 0x00FF is for normal event, 0xF000 is for prescale single event, and 0xFF00 is for cosmic event.
\item[packet\_num] Raw data of the packet number word of this trigger packet.
\item[time\_stamp] Raw data of the timestamp register double word of this trigger packet. The number of valid bits is 32. The unit of it is $80ns$.
\item[frm\_ship\_time] Raw data of the 6 bytes ship time decoded from the header of frame in which this trigger packet is.
\item[frm\_gps\_time] Raw data of the 6 bytes GPS time decoded from the header of frame in which this trigger packet is.
\item[status] Raw data of the status register word of this trigger packet.
\item[status\_bit] This is a C struct of pure bool type which is used to extract and store each bit of status respectively.
  Names of the fields indicate the meaning of each bit.
\item[trig\_sig\_con[25]] Array to store the byte of trigger signals conditions for each frontend.
\item[trig\_sig\_con\_bit] C struct to extract and store each bit of trigger signals conditions for each frontend respectively.
  Each field of this C struct is of type bool[25].
\item[trig\_accepted[25]] Array to store each bit of FEE TRIGGER ACCEPTED for each frontend respectively.
\item[trig\_rejected[25]] Array to store each bit of FEE TRIGGER REJECTED for each frontend respectively.
\item[raw\_dead] Raw data of the dead time counter word of this trigger packet.
\end{asparadesc}

\subsubsection{Auxiliary data in t\_trigger}
Some of the auxiliary data added in t\_trigger is similar to that is added in t\_modules.
Some are used to organize the event data, that is, to find the corresponding module packets of the same event in t\_modules.
The three GPS related branches with a star tagged shown in Table \ref{tab:t-trigger} are added by program \texttt{Time\_Calculate}. 
They belong to the 1P level SCI data, and the 1M level SCI data does not have these three branches.
All the auxiliary data in t\_trigger is listed and explained below.

\begin{asparadesc}
\item[trigg\_num] Sequential number of trigger packet.
  Like event\_num of \\ t\_modules, this number is independent for pedestal and physical trigger packets
  and is always continuous and incremental in the same TTree, t\_trigger or t\_ped\_trigger.
  It start from 0, and it is $-1$ when this trigger packet is bad.
\item[trigg\_num\_g] Order number of the sequence of appearing in the raw data file.
  Also similar to event\_num\_g for module packets, this number is added when scanning the raw data file and counts both pedestal and physical trigger packets.
  Because pedestal and physical trigger packets are stored in different TTree, This number is incremental but sometimes discontinuous in the same TTree.
  It start from 0, and it is $-1$ when this trigger packet is bad.
\item[is\_bad] The same as that in t\_modules but for trigger packets.
\item[pre\_is\_bad] The same as that in t\_modules but for trigger packets.
\item[time\_period] The same as that in t\_modules but for trigger packets. time\_stamp of trigger packet will overflow about every 5.73 minutes.
\item[time\_align] It is the 23 MSB of time\_stamp of this trigger packet. It is also useful for time alignment.
  It is the counterpart of 23 LSB of time\_stamp of module packet.
\item[time\_second] Time in second unit from start when this trigger packet is generated.
  It is equal to $(\textrm{time\_period} \times 2^{32} + \textrm{time\_stamp}) \times 80 \times 10^{-9}$.
\item[time\_wait] The same as that in t\_modules but for trigger packets.
\item[pkt\_start] This is the branch that records the first entry index of the module packets in t\_modules for the same event.
  In t\_modules, module packets that belong to the same event are adjacent to each other. The total number of module packets for the same event is recorded by pkt\_count.
  The value of pkt\_start is $-1$ when this trigger packet loses all event packets, and -2 when this trigger packet is bad.
\item[pkt\_count] This is the branch that records the total number of module packets in t\_modules that belong to the same event as this trigger packet.
  We can use pkt\_start and pkt\_count to find all the corresponding module packets of this trigger packet in t\_modules.
\item[lost\_count] An integer value that indicates how many packets this event loses. There are two reasons for the lost.
  The first is that it is realy lost. And the second is that some module packets failed to time align with this trigger packet because of possible timestamp issue.
\item[trigger\_n] Sum of the trigger\_bit[64] of all the module packets of this event. It is the number of how many bars are fired in this event. It may includes several modules.
\item[dead\_ratio] It should be the same as that of t\_modules, but there is a difference. For trigger packets,
  $\textrm{dead\_ratio} = pre\Delta(\textrm{raw\_dead}) / \Delta(\textrm{time\_stamp})$.
  That means $\textrm{dead\_ratio}_3 = \frac{\textrm{raw\_dead}_2 - \textrm{raw\_dead}_1}{\textrm{time\_stamp}_3 - \textrm{time\_stamp}_2}$.
\item[abs\_gps\_week] Added by \texttt{Time\_Calculate}. It is the week of absolute GPS time when this event occurred.
\item[abs\_gps\_second] Added by \texttt{Time\_Calculate}. It is the second of absolute GPS time when this event occurred.
\item[abs\_gps\_valid] Added by \texttt{Time\_Calculate}. It indicates if the absolute GPS time is valid.
\end{asparadesc}

\subsubsection{Iterating pedestal and physical packets together}
Because of the different mehtods of doing time alignment for pedestal and physical packets, if save both pedestal packets and physical packets in the same TTree,
it is hard to make the sequence between pedestal and physical packets as the order of time.
But it is easy to make the sequence of only pedestal or physical packets as the order of time in the same TTree.
So I have to save pedestal and physical data separately.
But sometimes it is needed to iterate pedestal and physical packets together as the order of time.
We can use event\_num\_g in both t\_modules and t\_ped\_modules, and trigg\_num\_g in both t\_trigger and t\_ped\_trigger to do this thing easily.
event\_num\_g (for module packets) and trigg\_num\_g (for trigger packets) are added when scanning the raw data file.
They are the order of appearing in raw data file of the packet. Pedestal and physical packets for the same module use the same counter.
In pedestal and physical TTree, event\_num\_g (or trigger\_num\_g) looks like Table \ref{tab:event-num-g}.

\begin{table}[htbp]
  \centering
  \caption{number in t\_modules and t\_ped\_modules}\label{tab:event-num-g}
  \begin{tabular}{| c | c !{\vrule\,\vrule} c | c |}\hline
    \multicolumn{2}{| c !{\vrule\,\vrule}}{\textbf{t\_ped\_modules}}   & \multicolumn{2}{ c |}{\textbf{t\_modules}} \\\hline
    event\_num        & event\_num\_g         & event\_num        & evnet\_num\_g \\\hline
    0                 & 0                     &                   &               \\\hline
    1                 & 1                     &                   &               \\\hline
    2                 & 2                     &                   &               \\\hline
                      &                       & 0                 & 3             \\\hline
                      &                       & 1                 & 4             \\\hline
                      &                       & 2                 & 5             \\\hline
                      &                       & 3                 & 6             \\\hline
    3                 & 7                     &                   &               \\\hline
                      &                       & 4                 & 8             \\\hline
                      &                       & 5                 & 9             \\\hline
    4                 & 10                    &                   &               \\\hline
                      &                       & 6                 & 11            \\\hline
                      &                       & 7                 & 12            \\\hline
                      &                       & 8                 & 13            \\\hline
  \end{tabular}
\end{table}

Notice that event\_num and event\_num\_g are all independent for different modules.
Table \ref{tab:event-num-g} just shows the case of only a specific module.

It is clear that we can open the two TTree t\_ped\_modules and t\_modules at the same time and iterate both pedestal
and physical packets of one specific module together as the order of time by comparing event\_num\_g.
For trigger packets, the method is the same, by comparing trigg\_num\_g.

Notice that event\_num is ``local'' in the same TTree t\_ped\_modules or t\_modules,
but event\_num\_g is ``global'' between the two TTree t\_ped\_modules and t\_modules. That is what the suffix ``\_g'' mean.

\subsubsection{Organization of event data}
Data of an event (both pedestal and physical) contains one trigger packet and one or more module packets.
Packets of trigger and module have different data structure, so they must be stored in different TTree.
But the matching between trigger packet and module packet of the same event is also important.
For one trigger packet in t\_trigger, we have to know which module packets in t\_modules are the corresponding module packets of the same event.
And on the contrary, for one module packet in t\_modules, we have to know which trigger packet in t\_trigger is the corresponding trigger packet of the same event.
Six extra branches in t\_trigger and t\_modules are used to do this kind of data organization.
They are trigg\_num, pkt\_start, pkt\_count, lost\_count in trigger packet, and trigg\_num, event\_num in t\_modules.
The relationship among them is shown in Table \ref{tab:org-event-data}.

\begin{table}[htbp]
  \centering
  \caption{organization of event data between t\_trigger and t\_modules}\label{tab:org-event-data}
  \scriptsize
  \begin{tabular}{| c | c | c | c !{\vrule\,\vrule} c | c | c | c |}\hline
    \multicolumn{4}{| c !{\vrule\,\vrule}}{\textbf{t\_trigger}}   & \multicolumn{4}{ c |}{\textbf{t\_modules}} \\\hline
    entry & trigg\_num  & pkt\_start & pkt\_count    & entry & trigg\_num    & ct\_num & event\_num  \\\hline
    0     & 0           & 0          & 2             & 0     & 0             & 2       & 0           \\\hline
          &             &            &               & 1     & 0             & 3       & 0           \\\hline
    1     & 1           & 2          & 3             & 2     & 1             & 8       & 0           \\\hline
          &             &            &               & 3     & 1             & 7       & 0           \\\hline
          &             &            &               & 4     & 1             & 2       & 1           \\\hline
    2     & 2           & 5          & 1             & 5     & 2             & 3       & 1           \\\hline
    3     & 3           & 6          & 2             & 6     & 3             & 6       & 0           \\\hline
          &             &            &               & 7     & 3             & 7       & 1           \\\hline
    4     & 4           & 8          & 2             & 8     & 4             & 3       & 2           \\\hline
          &             &            &               & 9     & 4             & 4       & 0           \\\hline
    5     & 5           & 10         & 3             & 10    & 5             & 12      & 0           \\\hline
          &             &            &               & 11    & 5             & 7       & 2           \\\hline
          &             &            &               & 12    & 5             & 8       & 1           \\\hline
    6     & 6           & 13         & 1             & 13    & 6             & 3       & 3           \\\hline
    7     & 7           & 14         & 2             & 14    & 7             & 2       & 2           \\\hline
          &             &            &               & 15    & 7             & 3       & 4           \\\hline
  \end{tabular}
\end{table}

The organization of event data between t\_trigger and t\_modules is shown clearly in Table \ref{tab:org-event-data}.
There are two key rules:
1) trigger packet in TTree t\_trigger records the position of modules packets in TTree t\_modules using pkt\_start and pkt\_count;
2) module packet in TTree t\_modules records the trigg\_num of the trigger packet in TTree t\_trigger of the same event.
trigg\_num is unique for each trigger packet in t\_trigger.
event\_num of module packets in t\_modules is independent for different modules, but unique for a specific module.

This organization looks some complicated. But it has some advantages comparing just storing the ADC data of one event into a 1600 array.
Because the packet data is stored module by module, all data in module packet and trigger packet can be kept.
And it is helpful for data analysis, because some steps of the analysis chain, such as pedestal subtraction, crosstalk correction and energy calibration,
are always done module by module. Only the calculation of scattering angle is done in the whole instrument scope.
Though, the disadvantage is that we have to keep the structure not changed when we do pedestal subtraction, crosstalk correction and energy calibration etc. before
doing the calculation of scattering angle.

When we want to merge the module data of each event into a 1600 array, or when we calculate the scattering angle directly, we must iterate the data event by event.
The best way to do this is as following.

\begin{Verbatim}[fontsize=\scriptsize, frame=lines, numbers=left]
// value declaration. 
t_trigger->SetBranchAddress("pkt_start", pkt_start);
t_trigger->SetBranchAddress("pkt_count", pkt_count);
t_trigger->SetBranchAddress("lost_count", lost_count);
t_trigger->SetBracnhAddress("is_bad", trigg_is_bad);
// SetBranchAddress for other branches in t_trigger
t_modules->SetBranchAddress("ct_num", ct_num);
// SetBranchAddress for other branches in t_modules
for (Long64_t i = 0; i < t_trigger->GetEntries(); i++) {
    t_trigger->GetEntry(i);
    // when lost_count > 0, this event may lose module packets
    if (trigg_is_bad > 0 || lost_count > 0)
        continue;
    // process trigger packet data of this event.
    for (Long64_t j = pkt_start; j < pkt_start + pkt_count; j++) {
        t_modules->GetEntry(j);
        // process each module packet data of this event, 
        // merge them into a 1600 array or calculate scattering angle directly.
        // use ct_num to identify which module this packet is from.
        // do not need to check if this module packet is bad, 
        // because bad module packet can not be here.
    }
}  
\end{Verbatim}

In addition, the lost\_count branch records how many module packets this event loses.
When lost\_count is not 0, this event is bad, because it loses information.

\newpage

\subsection{1M level HK data}
HK data of 1M level is generated by \texttt{HK\_Decode}. There are 2 TTree objects, which store decoded data,
and some TNamed objects, which store meta information. Descriptions of them are shown in Table \ref{tab:1m-hk}.

\begin{table}[htbp]
  \centering
  \caption{Contents of ROOT file of 1M HK data}\label{tab:1m-hk}
  \begin{tabular}{| l | l | l |} \hline
    \textbf{Type}    & \textbf{Name}     & \textbf{Descriptions}                  \\\hline
    TTree            & t\_hk\_obox       & obox housekeeping packets              \\\hline
    TTree            & t\_hk\_ibox       & ibox housekeeping info                 \\\hline
    TNamed           & m\_dattype        & string of description of the data type \\\hline
    TNamed           & m\_version        & version of the program that generate this file \\\hline
    TNamed           & m\_gentime        & string of time when this file is generated \\\hline
    TNamed           & m\_rawfile        & list of file names of the raw data \\\hline
  \end{tabular}
\end{table}

The two TTree objects t\_hk\_obox and t\_hk\_ibox are used to store the decoded HK packets from IBOX and OBOX respectively.
HK packet from OBOX is generated with a periodicity of 2 seconds. And it will be divided into two HK packets in IBOX,
and packed into odd and even packets. t\_hk\_obox is to store the whole HK packet from OBOX after the two half packets divided into odd and even packets are combined.
t\_hk\_ibox is to store the other information except for that of OBOX HK packet in an IBOX HK packet, such as command feedback from OBOX.

\subsubsection{Contents table of TTree}
Like SCI data, here will give the table of contents of the two TTree objects first.

Firstly the contents of TTree t\_hk\_obox are shown in Table \ref{tab:t-hk-obox}.

\begin{center}
  \tablecaption{Contents of TTree t\_hk\_obox}\label{tab:t-hk-obox}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{3}{r}{\small Table \ref{tab:t-hk-obox} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{3}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{supertabular}{| p{18mm} | p{38mm} | p{66mm} |}
    Int\_t      & odd\_index               & Frame Index of odd packet, -1 when lost. \\\hline
    Int\_t      & even\_index              & Frame Index of even packet, -1 when lost. \\\hline
    Int\_t      & odd\_is\_bad             & code that indicates if the odd half packet is bad. 3 when lost, 2 when invalid, 1 when crc error, 0 when good. \\\hline
    Int\_t      & even\_is\_bad            & code that indicates if the even half packet is bad. 3 when lost, 2 when invalid, 1 when crc error, 0 when good. \\\hline
    Int\_t      & obox\_is\_bad            & code that indicates if the whole obox packet is bad. 3 when half, 2 when invalid, 1 when crc error, 0 when good. \\\hline
    UShort\_t   & packet\_num              & raw data of the Packet number word \\\hline
    UInt\_t     & timestamp                & raw data of the OBOX time-stamp double word \\\hline
    UChar\_t    & obox\_mode               & raw data of the 4 bits OBOX operational mode \\\hline
    UShort\_t   & cpu\_status              & raw data of the 12 bits OBOX CT CPU status \\\hline
    UChar\_t    & trig\_status             & raw data of the OBOX CT Trigger status byte \\\hline
    UChar\_t    & comm\_status             & raw data of the OBOX CT Communication status byte \\\hline
    Float\_t    & ct\_temp                 & physical value of the Central Trigger temperature  \\\hline
    Float\_t    & chain\_temp              & physical value of the Sensor chain temperature \\\hline
    UShort\_t   & reserved                 & raw data of the Reserved word \\\hline
    UShort\_t   & lv\_status               & raw data of the LV power supply status word \\\hline
    UInt\_t     & fe\_pattern              & raw data of the FEs powered double word \\\hline
    Float\_t    & lv\_temp                 & physical value of the LV power supply temperature \\\hline
    UShort\_t   & hv\_pwm                  & raw data of the HV PWM setting word \\\hline
    UShort\_t   & hv\_status               & raw data of the HV power supply status word \\\hline
    UShort\_t   & hv\_current[2]           & raw data of the HV current readout1 and readout2 words \\\hline
    UChar\_t    & fe\_status[25]           & raw data of the Module status byte of each module \\\hline
    Float\_t    & fe\_temp[25]             & physical value of the Module temperature of each module \\\hline
    Float\_t    & fe\_hv[25]               & physical value of the HV voltage setting of each module \\\hline
    Float\_t    & fe\_thr[25]              & physical value (if packet\_num \% 4 == 0) or raw data (if packet\_num \% 4 != 0) of the Threshold setting of each module \\\hline
    UShort\_t   & fe\_rate[25]             & raw data of the Count rate word of each module \\\hline
    UShort\_t   & fe\_cosmic[25]           & raw data of the Too many/too high rate word of each module \\\hline
    Float\_t    & flex\_i\_p3v3[5]         & physical value of the Current at P3V3 rail of each FLEX \\\hline
    Float\_t    & flex\_i\_p1v7[5]         & physical value of the Current at P1V7 rail of each FLEX \\\hline
    Float\_t    & flex\_i\_n2v5[5]         & physical value of the Current at N2V5 rail of each FLEX \\\hline
    Float\_t    & flex\_v\_p3v3[5]         & physical value of the Voltage at P3V3 rail of each FLEX \\\hline
    Float\_t    & flex\_v\_p1v7[5]         & physical value of the Voltage at P1V7 rail of each FLEX \\\hline
    Float\_t    & flex\_v\_n2v5[5]         & physical value of the Voltage at N2V5 rail of each FLEX \\\hline
    Float\_t    & hv\_v\_hot               & physical value of the Voltage at HV Hot P3V3 rail \\\hline
    Float\_t    & hv\_i\_hot               & physical value of the Current at HV Hot P3V3 rail \\\hline
    Float\_t    & ct\_v\_hot[2]            & physical value of the Voltage at CT Hot P3V3 and 1V5 rail \\\hline
    Float\_t    & ct\_i\_hot[2]            & physical value of the Current at CT Hot P3V3 and 1V5 rail \\\hline
    Float\_t    & hv\_v\_cold              & physical value of the Voltage at HV Cold P3V3 rail \\\hline
    Float\_t    & hv\_i\_cold              & physical value of the Current at HV Cold P3V3 rail \\\hline
    Float\_t    & ct\_v\_cold[2]           & physical value of the Voltage at CT Cold P3V3 and 1V5 rail \\\hline
    Float\_t    & ct\_i\_cold[2]           & physical value of the Current at CT Cold P3V3 and 1V5 rail \\\hline
    UInt\_t     & timestamp\_sync          & raw data of the word of Time-stamp at last sync \\\hline
    UShort\_t   & command\_rec             & raw data of the byte of Command received counter \\\hline
    UShort\_t   & command\_exec            & raw data of the byte of Command executed counter \\\hline
    UShort\_t   & command\_last\_num       & raw data of the word of Command last executed number \\\hline
    UShort\_t   & command\_last\_stamp     & raw data of the word of Command last executed time-stamp \\\hline
    UShort\_t   & command\_last\_exec      & raw data of the word of Command last executed code \\\hline
    UShort\_t   & command\_last\_arg[2]    & raw data of the words of Command last executed argument1 and argument2 \\\hline
    UShort\_t   & obox\_hk\_crc            & raw data of the word of OBOX HK packet CRC \\\hline
    UShort\_t   & saa                      & raw data of the 2 bits SAA flat \\\hline
    UShort\_t   & sci\_head                & raw data of the word of OBOX science packet header counter \\\hline
    ULong64\_t  & gps\_pps\_count          & raw data of the 8 bytes Time\_PPS \\\hline
    ULong64\_t  & gps\_sync\_gen\_count    & raw data of the 8 bytes Time\_synchComGen \\\hline
    ULong64\_t  & gps\_sync\_send\_count   & raw data of the 8 bytes Time\_synchComTx \\\hline
    ULong64\_t  & ibox\_gps                & raw data of the 6 bytes IBOX GPS time of odd packet \\\hline
    Int\_t      & abs\_gps\_week           & the GPS week of ibox\_gps of this packet \\\hline
    Double\_t   & abs\_gps\_second         & the GPS second of ibox\_gps of this packet \\ 
  \end{supertabular}
\end{center}

Secondly, the contents of TTree t\_hk\_ibox are shown in Table \ref{tab:t-hk-ibox}.
\vspace{5mm}
\begin{center}
  \tablecaption{Contents of TTree t\_hk\_ibox}\label{tab:t-hk-ibox}    
  \tablefirsthead{\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\\hline}
  \tablehead{
    \multicolumn{3}{r}{\small Table \ref{tab:t-hk-ibox} (Continue)}\\\hline
    \textbf{Type}  & \textbf{Name}  & \textbf{Descriptions} \\}
  \tabletail{\hline
    \multicolumn{3}{r}{\small Next}\\}
  \tablelasttail{\hline}
  \begin{supertabular}{| p{18mm} | p{38mm} | p{66mm} |}
    Int\_t      & frame\_index             & Frame Index of this packet \\\hline
    Int\_t      & pkt\_tag                 & Packet tag of this packet \\\hline
    Int\_t      & is\_bad                  & code that indicates if this packet is bad. 2 when invalid, 1 when CRC error, and 0 when good. \\\hline
    ULong64\_t   & ship\_time               & raw data of the 6 bytes Ship time of this packet \\\hline
    UShort\_t   & error[2]                 & raw data of the two words of Command feedback error number1 and number2 \\\hline
    UShort\_t   & frame\_head              & raw data of the Frame header word of the 6 words command feedback from OBOX \\\hline
    UShort\_t   & command\_head            & raw data of the Command frame header of the 6 words command feedback from OBOX \\\hline
    UShort\_t   & commnad\_num             & raw data of the Command number word of the 6 words command feedback from OBOX \\\hline
    UShort\_t   & command\_code            & raw data of the Command code word of the 6 words command feedback from OBOX \\\hline
    UShort\_t   & command\_arg[2]          & raw data of the two words of Command argument1 and argument2 of the 6 words command feedback from OBOX \\\hline
    ULong64\_t  & ibox\_gps                & raw data of the 6 bytes IBOX GPS time of this packet \\\hline
    Int\_t      & abs\_gps\_week           & the GPS week of ibox\_gps of this packet \\\hline
    Double\_t   & abs\_gps\_second         & the GPS second of ibox\_gps of this packet \\ 
  \end{supertabular}
\end{center}

\subsubsection{Conversion of physical value}
The meaning of each branch in the two TTree t\_hk\_obox and t\_hk\_ibox is explained clearly in Table \ref{tab:t-hk-obox} and Table \ref{tab:t-hk-ibox}.
There is no need to give more detailed information of them in this document.
What we concern more about is how the physcial values are converted from raw data. 
Notice that all branches in t\_hk\_obox with type Float\_t are physical value converted.
Here will give the formula of each of them.

\begin{asparadesc}
\item[ct\_temp] raw data of it is one word. \\
  ct\_temp = raw\_data[11:4] $>$ 0x7F ? raw\_data[11:4] - 2 * 0x80 : raw\_data[11:4]
\item[chain\_temp] raw data of it is one word. \\
  chain\_temp = raw\_data[11:4] $>$ 0x7F ? raw\_data[11:4] - 2 * 0x80 : raw\_data[11:4]
\item[lv\_temp] raw data of it is one word. \\
  lv\_temp = 27 + ((raw\_data - 0x8000) / 16384.0 * 2.5 / 2 - 28E-3) / 93.5E-6
\item[fe\_temp[25]] raw data of it is one byte for each module. \\
  fe\_temp = raw\_data $>$ 0x7F ? raw\_data - 2 * 0x80 : raw\_data
\item[fe\_hv[25]] raw data of it is one word for each module. \\
  fe\_hv = raw\_data[15:4] * 0.303
\item[fe\_thr[25]] raw data of it is one word for each module. \\
  fe\_thr = packet\_num \% 4 == 0 ? raw\_data / 4096.0 * 3.5 - 2.0 : raw\_data
\item[flex\_i\_p3v3[5]] raw data of it is one word. \\
  flex\_i\_p3v3 = (raw\_data - 0x8000) / 104.858
\item[flex\_i\_p1v7[5]] raw data of it is one word. \\
  flex\_i\_p1v7 = (raw\_data - 0x8000) / 104.858
\item[flex\_i\_n2v5[5]] raw data of it is one word. \\
  flex\_i\_n2v5 = (raw\_data - 0x8000) / 104.858
\item[flex\_v\_p3v3[5]] raw data of it is one word. \\
  flex\_v\_p3v3 = (raw\_data - 0x8000) / 4681.14
\item[flex\_v\_p1v7[5]] raw data of it is one word. \\
  flex\_v\_p1v7 = (raw\_data - 0x8000) / 8426.06
\item[flex\_v\_n2v5]] raw data of it is one word. \\
  flex\_v\_n2v5 = (raw\_data - 0x8000) / (-2407.44) + flex\_v\_p3v3
\item[hv\_v\_hot] raw data of it is one word. \\
  hv\_v\_hot = (raw\_data - 0x8000) / 4681.14
\item[hv\_v\_cold] raw data of it is one word. \\
  hv\_v\_cold = (raw\_data - 0x8000) / 4681.14
\item[hv\_i\_hot] raw data of it is one word. \\
  hv\_i\_hot = (raw\_data - 0x8000) / 104.858
\item[hv\_i\_cold] raw data of it is one word. \\
  hv\_i\_cold = (raw\_data - 0x8000) / 104.858
\item[ct\_v\_hot[2]] raw data of it is one word. \\
  ct\_v\_hot[0] = (raw\_data - 0x8000) / 4681.14 \\
  ct\_v\_hot[1] = (raw\_data - 0x8000) / 9011.20
\item[ct\_v\_cold[2]] raw data of it is one word. \\
  ct\_v\_cold[0] = (raw\_data - 0x8000) / 4681.14 \\
  ct\_v\_cold[1] = (raw\_data - 0x8000) / 9011.20
\item[ct\_i\_hot[2]] raw data of it is one word. \\
  ct\_i\_hot[0] = (raw\_data - 0x8000) / 104.858 \\
  ct\_i\_hot[1] = (raw\_data - 0x8000) / 104.858 
\item[ct\_i\_cold[2]] raw data of it is one word. \\
  ct\_i\_cold[0] = (raw\_data - 0x8000) / 104.858 \\
  ct\_i\_cold[1] = (raw\_data - 0x8000) / 104.858 
\end{asparadesc}

One thing should be noticed. Some data fields in OBOX HK packet provide multiple information, such as the Threshold setting.
Only when packet\_num \% 4 == 0, this field is the threshold value, it should be converted.
When packet\_num \% 4 == 1, 2 or 3, this field is some other counters, and it should not be converted.
See the housekeeping packet structure in document\cite{POLAR-OBOX-software} for more detail about this.

\newpage

\section{About splitting data by orbit}
After POLAR is in orbit, one file from POAC can be very big, because it may contains the data of one day.
The size of one data file can be several GBs. It must be not convenient to analyze so big a file at a time.
It is necessary to split the big decoded file into some small files. That may be a good way to split file by orbit,
because the orientation of POLAR, space environment, etc. are all changing periodically between differnt orbits.
The level of orbit splitted data is 1R.

\subsection{Some rules to obey when splitting data by orbit}
The orbit splitting program is not started yet. But here will list some rules that are planned to obey when splitting data by orbit.

\begin{enumerate}
\item The data structure of 1R level data (orbit splitted) should be the same as 1P level for SCI data and 1M level for HK data.
  So that the data monitor and data analysis software can apply to the data before and after splitted without any change.
\item Some index numbers, such as trigg\_num, trigg\_num\_g, event\_num, \\ event\_num\_g and pkt\_start in trigger packet should be rearranged.
  They all should be started from 0 in the small orbit splitted data file. \\ time\_second and time\_period should also be started from 0 after splitted.
\item The data is planned to be splitted by orbit according to GPS time when TG-2 pass through the start point of the orbit.
  We can get the time from the platform information in 1553B data.
\item A global orbit number should be added into each of the orbit splitted data files.
\end{enumerate}

%==== references =======================
\begin{thebibliography}{9}
\bibitem{POAC-data-products} POLAR\_space\_data\_from\_GESSA/POAC data products.pdf
\bibitem{POLAR-data-link} POLAR\_data\_link/Introduction\_of\_POLAR\_data\_link.pdf
\bibitem{POLAR-OBOX-software} TN\_318/POLAR\_OBOX\_Software\_Design\_Specification.pdf
\end{thebibliography}

\end{document}
